#!/bin/bash

# Keyword Finder - Search keyword inside the files.
# Copyright Â© 1995 Richard Huang <rickypc@users.noreply.github.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

: "${SEARCH_IGNORE_FILE:=.searchignore}"

usage() {
  printf "Usage: %s [-e <excluded folder> ...] -h <keyword> -s\n" "$(basename "$0")"
  printf "All command-line options are optional. The following flags are supported:\n"
  printf "  -e  -- Specify one or more folders to exclude from the search.\n"
  printf "  -h  -- Display this help message.\n"
  printf "  -s  -- Ignore the .searchignore file during execution.\n"
  exit "${1:-0}"
}

while getopts ":e:hs" opt; do
  case "$opt" in
    e) EXCLUDES+=("$OPTARG") ;;
    h) usage ;;
    s) SKIP_IGNORE=true ;;
    :)
      # Missing argument
      printf "Error: Option '-%s' requires an argument.\n" "$OPTARG" >&2
      usage 1 ;;
    ?)
      # Invalid option
      printf "Error: Invalid option '-%s'\n" "$OPTARG" >&2
      usage 1 ;;
  esac
done

shift $((OPTIND-1))

FIND_ARGS+="-not \( -path '*.git/*' -prune \)"

if [ "$SKIP_IGNORE" != true ]; then
  # Resolve the actual path by searching upward
  dir="$PWD"
  while [ "$dir" != "/" ]; do
    if [ -f "$dir/$SEARCH_IGNORE_FILE" ]; then
      SEARCH_IGNORE_PATH="$dir/$SEARCH_IGNORE_FILE"
      break
    fi
    dir="$(dirname "$dir")"
  done
  if [ -f "$SEARCH_IGNORE_PATH" ]; then
    while IFS= read -r EXCLUDE; do
      FIND_ARGS+=" -not \( -path '*$EXCLUDE*' -prune \)"
    done < "$SEARCH_IGNORE_PATH"
  fi
fi

if [ ! -z "$EXCLUDES" ]; then
  for EXCLUDE in "${EXCLUDES[@]}"; do
    FIND_ARGS+=" -not \( -path '*$EXCLUDE*' -prune \)"
  done
fi

KEYWORD="$1"
if [[ "$KEYWORD" =~ ^/(.*)/$ ]]; then
  PATTERN="${BASH_REMATCH[1]}"
else
  # Convert to a proper regex               # escape regex chars;           s/*/.*/g;  s/?/./g;
  PATTERN=$(printf '%s\n' "$KEYWORD" | sed 's/[.[\^$()+{}|\\]/\\&/g' | sed 's/\*/.*/g; s/\?/./g')
fi
eval "find . -type f $FIND_ARGS -print0 2>/dev/null" | xargs -0 grep --color=always -E --line-buffered -HIinrs "$PATTERN"
