server {
  listen                    443 ssl;
  listen                    [::]:443 ssl;
  server_name               *.test;
  root                      /usr/local/var/www/$host;
  access_log                /usr/local/var/log/nginx/host.test.access.log vhost;
  error_log                 /usr/local/var/log/nginx/host.test.error.log debug;

  ssl on;
  ssl_certificate           /usr/local/etc/openssl/certs/host.test.crt;
  ssl_certificate_key       /usr/local/etc/openssl/private/host.test.key;

  ssl_session_cache         shared:SSL:1m;
  ssl_session_timeout       5m;

  ssl_protocols             SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers               HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers on;

  location = /favicon.ico {
    access_log              off;
    log_not_found           off;
  }

  location = /robots.txt {
    access_log              off;
    allow                   all;
    log_not_found           off;
  }

  location ~* \.(txt|log)$ {
    allow                   127.0.0.1;
    deny                    all;
  }

  location ~ \..*/.*\.php$ {
    return 403;
  }

  location ~ ^/sites/.*/private/ {
    return 403;
  }

  # Block access to "hidden" files and directories whose names begin with a
  # period. This includes directories used by version control systems such
  # as Subversion or Git to store control files.
  location ~ (^|/)\. {
    return 403;
  }

  location / {
    # try_files $uri @rewrite;                  # For Drupal <= 6
    try_files $uri /index.php?$query_string;    # For Drupal >= 7
    index                   index.html index.php;
  }

  location @rewrite {
    rewrite ^/(.*)$ /index.php?q=$1;
  }

  # In Drupal 8, we must also match new paths where the '.php' appears in the middle,
  # such as update.php/selection. The rule we use is strict, and only allows this pattern
  # with the update.php front controller.  This allows legacy path aliases in the form of
  # blog/index.php/legacy-path to continue to route to Drupal nodes. If you do not have
  # any paths like that, then you might prefer to use a laxer rule, such as:
  #   location ~ \.php(/|$) {
  # The laxer rule will continue to work if Drupal uses this new URL pattern with front
  # controllers other than update.php in a future release.
  location ~ '\.php$|^/update.php' {
    fastcgi_split_path_info ^(.+?\.php)(|/.*)$;
    # NOTE: You should have "cgi.fix_pathinfo = 0;" in php.ini
    fastcgi_intercept_errors on;
    fastcgi_pass            unix:/usr/local/var/run/php-fpm.sock;
    fastcgi_param           SCRIPT_FILENAME $request_filename;
    include                 fastcgi_params;
  }

  # Fighting with styles? This little gem is amazing.
  # location ~ ^/sites/.*/files/imagecache/ {     # For Drupal <= 6
  location ~ ^/sites/.*/files/styles/ {           # For Drpal >= 7
    try_files $uri @rewrite;
  }

  location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
    expires                 max;
    log_not_found           off;
  }

  location ~ /\. {
    deny                    all;
  }
}
